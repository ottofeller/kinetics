use crate::client::Client;
use crate::commands::deploy::DeployConfig;
use crate::crat::Crate;
use crate::error::Error;
use crate::project::Project;
use base64::Engine as _;
use crc_fast::{CrcAlgorithm::Crc64Nvme, Digest};
use eyre::{eyre, ContextCompat, OptionExt, WrapErr};
use reqwest::StatusCode;
use serde_json::json;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use tokio::io::{AsyncBufReadExt, BufReader};

// Re-export types from kinetics-parser
pub use kinetics_parser::{ParsedFunction, Role};

pub enum Type {
    Cron,
    Endpoint,
    Worker,
}

/// Represents a function in the project
#[derive(Clone, Debug)]
pub struct Function {
    /// The name of the function
    pub name: String,

    /// Whether the function is requested for deployment
    pub is_deploying: bool,

    /// The role of the function with parameters
    pub role: Role,

    /// The crate that contains the function, it belongs to Crate in the build directory
    pub crat: Crate,
}

impl Function {
    pub fn new(crat: &Crate, function: &ParsedFunction) -> eyre::Result<Self> {
        Ok(Function {
            name: function.func_name(false)?,
            is_deploying: false,
            crat: crat.clone(),
            role: function.role.clone(),
        })
    }

    /// Try to find a function by name in the vec of functions
    pub fn find_by_name(functions: &[Function], name: &str) -> eyre::Result<Function> {
        functions
            .iter()
            .find(|f| name.eq(&f.name))
            .wrap_err("No function with such name")
            .cloned()
    }

    pub fn set_is_deploying(mut self, is_deploying: bool) -> Self {
        self.is_deploying = is_deploying;
        self
    }

    /// A path to zip file generated by cargo-lambda
    pub fn bundle_path(&self) -> PathBuf {
        self.crat
            .path
            .join("target")
            .join("lambda")
            .join(&self.name)
            .join("bootstrap.zip")
    }

    /// Call the /upload endpoint to get the presigned URL and upload the file
    /// Returns a boolean indicating whether the resource has been updated.
    pub async fn upload(
        &mut self,
        client: &Client,
        deploy_config: Option<&dyn DeployConfig>,
    ) -> eyre::Result<bool> {
        if let Some(config) = deploy_config {
            return config.upload(self).await;
        }

        #[derive(serde::Deserialize, Debug)]
        struct PreSignedUrl {
            url: String,
        }

        let path = self.bundle_path();
        let data = tokio::fs::read(&path).await?;

        let mut digest = Digest::new(Crc64Nvme);
        digest.update(&data);
        let checksum = base64::prelude::BASE64_STANDARD.encode(digest.finalize().to_be_bytes());
        let body = json!({"name": self.name, "checksum": checksum});

        log::debug!(
            "Calling /upload with body:\n{}",
            serde_json::to_string_pretty(&body)?
        );

        let response = client
            .post("/upload")
            .json(&body)
            .send()
            .await
            .inspect_err(|e| log::error!("Upload request failed: {e:?}"))?;

        // If the file has not changed, skip the upload.
        if response.status() == StatusCode::NOT_MODIFIED {
            return Ok(false);
        }

        let text = response.text().await?;
        log::debug!("Got response for {}: {}", self.name, text);

        let presigned = serde_json::from_str::<PreSignedUrl>(&text).inspect_err(|e| {
            log::error!("Failed to parse the response: {e:?}");
        })?;

        let public_client = reqwest::Client::new();

        public_client
            .put(&presigned.url)
            .body(data)
            .send()
            .await?
            .error_for_status()?;

        Ok(true)
    }

    /// Return env vars assigned to the function in macro definition
    pub fn environment(&self) -> HashMap<String, String> {
        match &self.role {
            Role::Endpoint(endpoint) => endpoint.environment.clone(),
            Role::Cron(cron) => cron.environment.clone(),
            Role::Worker(worker) => worker.environment.clone(),
        }
    }

    /// URL to call the function
    ///
    /// Only relevant for endpoint type of functions.
    pub async fn url(&self) -> eyre::Result<String> {
        let url_path = match &self.role {
            Role::Endpoint(endpoint) => endpoint.url_path.clone(),
            _ => None,
        }
        .ok_or_eyre("No URL path specified for the function (not an enpoint?)")?;

        Ok(format!(
            "{}{}",
            Project::one(&self.crat.project.name).await?.url,
            url_path
        ))
    }

    /// Get the function deployment status from the backend
    pub async fn status(&self, client: &Client) -> eyre::Result<Option<String>> {
        #[derive(serde::Serialize)]
        struct JsonBody {
            crate_name: String,
            function_name: String,
        }

        #[derive(serde::Deserialize)]
        struct JsonResponse {
            /// The date and time that the function was last updated
            /// in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
            last_modified: Option<String>,
        }

        let result = client
            .post("/function/status")
            .json(&JsonBody {
                crate_name: self.crat.project.name.clone(),
                function_name: self.name.clone(),
            })
            .send()
            .await
            .inspect_err(|err| log::error!("{err:?}"))
            .wrap_err(Error::new(
                "Network request failed",
                Some("Try again in a few seconds."),
            ))?;

        if result.status() != StatusCode::OK {
            return Err(Error::new(
                &format!(
                    "Function status request failed for {}/{}",
                    self.crat.project.name.clone(),
                    self.name.clone()
                ),
                Some("Try again in a few seconds."),
            )
            .into());
        }

        let status: JsonResponse = result.json().await.wrap_err("Failed to parse response")?;

        Ok(status.last_modified)
    }
}

pub async fn build(
    functions: &[Function],
    total_progress: &indicatif::ProgressBar,
) -> eyre::Result<()> {
    let Some(Function { crat, .. }) = functions.iter().next() else {
        return Err(eyre!("Attempted to build an empty function list"));
    };

    total_progress.set_message("Starting cargo...");
    let mut cmd = tokio::process::Command::new("cargo");
    cmd.arg("lambda")
        .arg("build")
        .arg("--release")
        .arg("--target")
        .arg("x86_64-unknown-linux-musl")
        .arg("--output-format")
        .arg("zip")
        .current_dir(&crat.path)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    for function in functions {
        cmd.arg("--bin").arg(&function.name);
    }

    let mut child = cmd.spawn().wrap_err("Failed to execute the process")?;

    let mut is_failed = false;
    let mut error_message_lines = Vec::new();

    if let Some(stderr) = child.stderr.take() {
        let mut reader = BufReader::new(stderr).lines();
        let regex = regex::Regex::new(r"^[\t ]+")?;

        while let Some(line) = reader.next_line().await? {
            if line.trim().starts_with("error") || is_failed {
                is_failed = true;
                error_message_lines.push(line);
                continue;
            };
            total_progress.set_message(regex.replace_all(&line, "").to_string());
        }
    }

    total_progress.set_message("");
    let status = child.wait().await?;

    if !status.success() {
        return Err(eyre!("{}", error_message_lines.join("\n")));
    }

    Ok(())
}
